#!/usr/bin/env python
#
# Copyright 2016 Henric Andersson
#
# The base for a shell like interface to your smartthings account,
# allowing the following:
#
# - Create SA/DTH
# - Upload one or more files to SA/DTH
# - Download one or more files and complete SA/DTH
# - Delete one or more files or complete SA/DTH
# - Programmatic interface
# - FTP like interface.
#
# STShell is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# STShell is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with STShell.  If not, see <http://www.gnu.org/licenses/>.
#
import argparse
import os
import sys
import re

from classes.console import ConsoleAccess
from classes.stshell import STServer

parser = argparse.ArgumentParser(description="ST Shell - Command Line access to SmartThings WebIDE", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-u', '--username', default=None, metavar="EMAIL", help="EMail used for logging into WebIDE")
parser.add_argument('-p', '--password', default=None, help="Password for the account")
parser.add_argument('--server', default="graph.api.smartthings.com", help="Change server to connect to")

subparser = parser.add_subparsers()

parser_list = subparser.add_parser('list', help='Lists all smartapps or devicetype handlers')
parser_list.set_defaults(action="list")
parser_list.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")

parser_contents = subparser.add_parser('contents', help='Lists contents of selected bundle')
parser_contents.set_defaults(action="contents")
parser_contents.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")
parser_contents.add_argument('UUID', help="The UUID of the bundle to view the contents of")

parser_download = subparser.add_parser('download', help='Download an entire bundle or select parts of it')
parser_download.set_defaults(action="download")
parser_download.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")
parser_download.add_argument('UUID', help="The UUID of the bundle to download")
parser_download.add_argument('--item', default=None, help="If defined, the UUID of the item inside the bundle to download", dest='ITEM')

parser_create = subparser.add_parser('create', help="Create a new bundle")
parser_create.set_defaults(action="create")
parser_create.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")
parser_create.add_argument('FILE', help="Groovy file for a SmartApp or DeviceType to use for creating the bundle")

parser_upload = subparser.add_parser('upload', help='Upload a file to an existing bundle')
parser_upload.set_defaults(action="upload")
parser_upload.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")
parser_upload.add_argument('UUID', help="The UUID of the bundle")
parser_upload.add_argument('TYPE', type=str.upper, choices=STServer.UPLOAD_TYPE.keys(), help="What kind of file (determines base folder)")
parser_upload.add_argument('--path', default="", help="What subpath to place it under", dest='PATH')
parser_upload.add_argument('FILE', help="The file to upload")

parser_delete = subparser.add_parser('delete', help="Delete a bundle or item in a bundle")
parser_delete.set_defaults(action="delete")
parser_delete.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")
parser_delete.add_argument('UUID', help="The UUID of the bundle to delete (or delete from)")
parser_delete.add_argument('--item', default=None, help='The item in the bundle to delete', dest='ITEM')

parser_update = subparser.add_parser('update', help='Update an item in the bundle')
parser_update.set_defaults(action="update")
parser_update.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")
parser_update.add_argument('UUID', help="The UUID of the bundle to update")
parser_update.add_argument('ITEM', help='The item in the bundle to update')
parser_update.add_argument('FILE', help='The changed file to update the item with')

parser_publish = subparser.add_parser('publish', help="Publish a SmartApp or DeviceType")
parser_publish.set_defaults(action="publish")
parser_publish.add_argument('KIND', type=str.upper, choices=["SA", "DTH"], help="Choose what to operate on (smartapp or devicetype)")
parser_publish.add_argument('UUID', help="The UUID of the bundle to delete (or delete from)")

parser_console = subparser.add_parser('console', help='Enter console mode')
parser_console.set_defaults(action='console')

cmdline = parser.parse_args()

# Try loading the settings
try:
    with open(os.path.expanduser('~/.stshell'), "r") as f:
        p = re.compile('([^=]+)=(.+)')
        for line in f:
            m = p.match(line)
            if m:
                if m.group(1) == "username":
                    cfg_username = m.group(2).strip()
                elif m.group(1) == "password":
                    cfg_password = m.group(2).strip()
                else:
                    print("Unknown parameter: %s" % (m.group(0)))
except:
    pass

if cmdline.username is not None:
    cfg_username = cmdline.username
if cmdline.password is not None:
    cfg_password = cmdline.password

if cfg_username is None or cfg_password is None:
    print("ERROR: Username and password cannot be empty")
    sys.exit(255)

if cmdline.action == "console":
    sys.stderr.write("Logging in...")
    sys.stderr.flush()
srv = STServer(cfg_username, cfg_password, "https://" + cmdline.server)

success = srv.login()
if cmdline.action == "console":
    if success:
        sys.stderr.write("Done\n")
    else:
        sys.stderr.write("Failed! Invalid credentials?\n")
        sys.exit(255)
    sys.stderr.flush()
if not success:
    print("Failed to login, invalid credentials?")
    sys.exit(255)

if cmdline.action == "list":
    # Lists all SA or DTHs
    if cmdline.KIND == "DTH": # DTH
        types = srv.listDeviceTypes()
    else:
        types = srv.listSmartApps()
    for t in types.values():
        print("%36s | %s : %s" % (t["id"], t["namespace"], t["name"]))
elif cmdline.action == "contents":
    # Shows the files inside a SA/DTH
    if cmdline.KIND == "DTH": # DTH
        contents = srv.getDeviceTypeDetails(cmdline.UUID)
    else:
        contents = srv.getSmartAppDetails(cmdline.UUID)
    for k,v in contents["flat"].iteritems():
        print("%36s | %s" % (k, v))
elif cmdline.action == "download":
    if cmdline.KIND == "DTH": # DTH
        if cmdline.ITEM:
            contents = srv.getDeviceTypeDetails(cmdline.UUID)
            data = srv.downloadDeviceTypeItem(cmdline.UUID, contents["details"], cmdline.ITEM)
            with open("./" + data["filename"], "wb") as f:
                f.write(data["data"])
        else:
            srv.downloadDeviceType(cmdline.UUID, "./")
    else:
        if cmdline.ITEM:
            contents = srv.getSmartAppDetails(cmdline.UUID)
            data = srv.downloadSmartAppItem(cmdline.UUID, contents["details"], cmdline.ITEM)
            with open("./" + data["filename"], "wb") as f:
                f.write(data["data"])
        else:
            srv.downloadSmartApp(cmdline.UUID, "./")
elif cmdline.action == "create":
    # Creates a new project, requires a groovy file
    with open(cmdline.FILE, "rb") as f:
        data = f.read()

    if cmdline.KIND == "DTH": # DTH
        result = srv.createDeviceType(data)
        if result:
            print("DeviceType Handler %s created" % result)
        else:
            print("Failed to create DeviceType Handler")
    else:
        result = srv.createSmartApp(data)
        if result:
            print("SmartApp %s created" % result)
        else:
            print("Failed to create SmartApp")
elif cmdline.action == "delete":
    # Deletes an ENTIRE bundle, will prompt before doing so
    if cmdline.KIND == "DTH": # DTH
        contents = srv.listDeviceTypes()
    else:
        contents = srv.listSmartApps()
    if not cmdline.UUID in contents:
        print("ERROR: No such item")
        sys.exit(255)
    else:
        content = contents[cmdline.UUID]

    if cmdline.ITEM is None:
        sys.stderr.write('Are you SURE you want to delete "%s : %s" (yes/NO) ? ' % (content["namespace"], content["name"]))
        sys.stderr.flush()
        choice = sys.stdin.readline().strip().lower()
        if choice == "yes":
            sys.stderr.write("Deleting: ")
            sys.stderr.flush()
            if cmdline.KIND == "DTH": # DTH
                srv.deleteDeviceType(cmdline.UUID)
            else:
                srv.deleteSmartApp(cmdline.UUID)
            sys.stderr.write("Done\n")
        else:
            sys.stderr.write("Aborted\n")
    else:
        if cmdline.KIND == "DTH": # DTH
            contents = srv.getDeviceTypeDetails(cmdline.UUID)
        else:
            contents = srv.getSmartAppDetails(cmdline.UUID)

        if cmdline.ITEM not in contents["flat"]:
            print("ERROR: No such item in bundle")
            sys.exit(255)
        sys.stderr.write('Are you SURE you want to delete "%s" from "%s : %s" (yes/NO) ? ' % (contents["flat"][cmdline.ITEM], content["namespace"], content["name"]))
        sys.stderr.flush()
        choice = sys.stdin.readline().strip().lower()
        if choice == "yes":
            sys.stderr.write("Deleting: ")
            sys.stderr.flush()
            if cmdline.KIND == "DTH": # DTH
                srv.deleteDeviceTypeItem(cmdline.UUID, cmdline.ITEM)
            else:
                srv.deleteSmartAppItem(cmdline.UUID, cmdline.ITEM)
            sys.stderr.write("Done\n")
        else:
            sys.stderr.write("Aborted\n")


elif cmdline.action == "upload":
    # Load content and change filename into the basename
    with open(cmdline.FILE, "rb") as f:
        data = f.read()
    filename = os.path.basename(cmdline.FILE)

    if cmdline.TYPE not in STServer.UPLOAD_TYPE:
        print("ERROR: Only certain types are supported: " + repr(STServer.UPLOAD_TYPE))
        sys.exit(255)

    # Download the list of files so we don't try to overwrite (which won't work as you'd expect)
    if cmdline.KIND == "DTH": # DTH
        details = srv.getDeviceTypeDetails(cmdline.UUID)
    else:
        details = srv.getSmartAppDetails(cmdline.UUID)

    prospect = "/%s/%s/%s" % (STServer.UPLOAD_TYPE[cmdline.TYPE], cmdline.PATH, filename)
    p = re.compile('/+')
    prospect = p.sub('/', prospect)

    if prospect in details["flat"].values():
        print('ERROR: "%s" already exists. Cannot replace/update files using upload action' % prospect)
        sys.exit(255)

    sys.stderr.write("Uploading content: ")
    sys.stderr.flush()
    if cmdline.KIND == "DTH": # DTH
        ids = srv.getDeviceTypeIds(cmdline.UUID)
        success = srv.uploadDeviceTypeItem(ids['versionid'], data, filename, cmdline.PATH, cmdline.TYPE)
    else:
        ids = srv.getSmartAppIds(cmdline.UUID)
        success = srv.uploadSmartAppItem(ids['versionid'], data, filename, cmdline.PATH, cmdline.TYPE)
    if success:
        sys.stderr.write("OK\n")
    else:
        sys.stderr.write("Failed\n")
elif cmdline.action == "update":
    # Bundle UUID, item UUID, new content
    with open(cmdline.FILE, 'rb') as f:
        data = f.read()

    if cmdline.KIND == "DTH": # DTH
        details = srv.getDeviceTypeDetails(cmdline.UUID)
    else:
        details = srv.getSmartAppDetails(cmdline.UUID)

    if cmdline.ITEM not in details["flat"]:
        print('ERROR: Item is not in selected bundle')
        sys.exit(255)

    sys.stderr.write("Updating content: ")
    sys.stderr.flush()
    if cmdline.KIND == "DTH": # DTH
        result = srv.updateDeviceTypeItem(details["details"], cmdline.UUID, cmdline.ITEM, data)
    else:
        result = srv.updateSmartAppItem(details["details"], cmdline.UUID, cmdline.ITEM, data)
    if "errors" in result and result["errors"]:
        print("Errors:")
        for e in result["errors"]:
            print("  " + e)
    if "output" in result and result["output"]:
        print("Details:")
        for o in result["output"]:
            print("  " + o)
    if not result["errors"] and not result["output"]:
        print("OK")
    else:
        sys.exit(1)
elif cmdline.action == "console":
    print("Welcome to STShell's console mode, allowing a FTP like access to the backend")
    print('Type "help" to get a list of commands, "help <command>" for details')
    console = ConsoleAccess()
    console.setConnection(srv)
    console.cmdloop()
    print("")
elif cmdline.action == "publish":
    # Deletes an ENTIRE bundle, will prompt before doing so
    sys.stderr.write("Publishing changes: ")
    sys.stderr.flush()

    if cmdline.KIND == "DTH": # DTH
        contents = srv.listDeviceTypes()
    else:
        contents = srv.listSmartApps()
    if not cmdline.UUID in contents:
        print("ERROR: No such item")
        sys.exit(255)

    if cmdline.KIND == "DTH":
        result = srv.publishDeviceType(cmdline.UUID)
    else:
        result = srv.publishSmartApp(cmdline.UUID)
    if result:
        print("OK")
    else:
        print("Failed")
